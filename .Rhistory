Par_cov <- cov_func(r = R,params,...)
if(loss=="WLS"){
# Weighted least squares of covariance only (VARIANCE excluded!)
mean(((Emp_Cov-Par_cov)/abs(1-cov2cor(Par_cov)))[R!=0]^2)
}else if(loss=="LS"){
# Least squares (including variance)
mean((Emp_Cov-Par_cov))^2
}else{
stop("Loss not recognised.")
}
}
#
# Need to add smoothness parameter - ridge penalty
#
#' Generalised Additive Covariance Functions
#'
#' Function to fit a covairance function with generalised additive-type models
#' for parameters.
#'
#' @author Jethro Browell, \email{jethro.browell@@glasgow.ac.uk}
#' @param params R Separation matrix
#' @param X Some container of covariates, e.g. a list with elements same size as \code{R}
#' @param Emp_CovEmpirical covaraiance to fit model to
#' @param cov_func A parametric covarianve function
#' @param param_eqns A list of equations for each parameter of \code{cov_func}
#' @param param_init Parameter values to initialise optimisaion
#' @param loss Chosen loss function. Options are:
#' \itemize{
#'  \item{"WLS"}{Weighted Leased Squares - weigthing by correlation.}
#'  \item{"LS"}{Least Squares}
#' }
#' @details Fits models for generalised additive covariance functions. Work in progress!
#' @return Returns an object of class \code{gac} for which methods will be writtern...
#' @keywords Covariance Function
#' @export
gac <- function(R,
X,
Emp_Cov,
cov_func,
param_eqns,
param_init=NULL,
loss="WLS"){
## Create modeling table of expanded basis from param_equations
modelling_table <- data.frame(y=c(Emp_Cov),
r=c(R))
design_mat <- list()
for(i in names(X)){
modelling_table[[i]] <- c(X[[i]])
}
for(i in 1:length(param_eqns)){
design_mat[[i]] <- model.matrix(param_eqns[[i]],data = modelling_table)
}
## Create objective function for model parameters ~ need some penalty on smoothness?
internal_gac_obj <- function(gac_coef
#,design_mat,R,Emp_Cov,cov_func
){
# Calculate parametric covairance matrix from supplied parameters and equations/design matrix
n_gac_coef <- unlist(lapply(design_mat,ncol))
params <- list()
for(i in 1:length(design_mat)){
params[[i]] <-  matrix(design_mat[[i]] %*% gac_coef[
sum(n_gac_coef[0:(i-1)])+1:n_gac_coef[i]],
ncol = ncol(R))
}
gac_obj(params = params,R = R,Emp_Cov = Emp_Cov,cov_func = cov_func,loss=loss,optim_bound=T)
}
## Estimate parameters
# Prep initial values
if(is.null(param_init)){
param_init <- rep(1,length(param_eqns))
}
gac_coef_init <- c()
for(i in 1:length(design_mat)){
gac_coef_init <- c(gac_coef_init,param_init[i],rep(0,ncol(design_mat[[i]])-1))
}
# Check first evaluation...
temp_test <- try(internal_gac_obj(gac_coef = gac_coef_init,design_mat = design_mat,
R = R,Emp_Cov = Emp_Cov,cov_func = cov_func))
if(class(temp_test)=="try.error"){stop("First evaluation of objective function (with param_init) failed.")}
rm(temp_test)
# Perform optimisation...
Fit1 <- optim(par=gac_coef_init,
fn=internal_gac_obj,
# design_mat = design_mat,
# R=R,
# loss=loss,
# Emp_Cov = Emp_Cov,
# cov_func=cov_func,
method="BFGS")
## Return as "gac" class
param_est <- list()
gac_coef <- list()
n_gac_coef <- unlist(lapply(design_mat,ncol))
for(i in 1:length(design_mat)){
gac_coef[[i]] <- Fit1$par[sum(n_gac_coef[0:(i-1)])+1:n_gac_coef[i]]
param_est[[i]] <-  matrix(design_mat[[i]] %*% gac_coef[[i]],ncol = ncol(R))
}
output <- list(call=match.call(),
Cov_Est = cov_func(r=R,params = param_est),
param_est=param_est,
gac_coef=gac_coef)
class(output) <- "gac"
return(output)
}
test_fit <- gac(R = R,
X = list(x1=Z),
Emp_Cov = Cov_R_sim,
cov_func = PowExp,
param_eqns = list(~1,
~bs(x1,df=5,intercept = F),
~1),
loss="LS")
rm(list=ls())
rm(list=ls())
require(rstudioapi)
require(data.table)
require(plot3D)
require(plot3Drgl)
require(mvnfast)
require(splines)
require(roxygen2)
require(devtools)
setwd(dirname(getActiveDocumentContext()$path))
# Update package documentation
document(pkg = ".")
# Install from local repository
install(".")
# Load Package
require(gac)
## Notes for the future ####
# Try nls()... e.g. formula = cov ~ cov_function(...)
# End goal: estimate and sample mvn. This script focuses on estimating
# parametric contrivance functions.
# Alternative, estimate (sparse) precision matrix e.g. "glasso" then
# sample using "sparseMVN::rmvn.sparse()"...
## Form single-variate symmetric matrix, sample and fit  ####
r <- seq(0,3,by=0.1)
R <- as.matrix(dist(r))
Cov_R <- PowExp(R,params = c(sqrt(2),1.5,0.8))
# Cov_R <- Spherical(R)
image(t(Cov_R))
surf3D(matrix(r,length(r),length(r),byrow = F),
matrix(r,length(r),length(r),byrow = T),
Cov_R,
colvar = Cov_R, colkey = F, facets = F,bty="f",
xlab="Lead-time",ylab="Lead-time",zlab="Covariance",
zlim=c(0,1),theta = -10,phi = 10)
# plotrgl()
## Visualisations
# r <- seq(0,3,by=0.01)
# plot(r,PowExp(r),type="l",ylim = c(0,1.1))
# lines(r,Whittle_Matern(r),col=2)
# lines(r,Cauchy(r),col=3)
# lines(r,Spherical(r,theta = 2),col=4)
## Sample
data_sim <- mvnfast::rmvn(n = 2^11,mu=rep(0,ncol(Cov_R)),sigma = Cov_R)
Cov_R_sim <- cov(data_sim)
image(t(Cov_R_sim))
image(t(Cov_R_sim-Cov_R))
gac_obj(c(1,1,1),R,Cov_R_sim,cov_func=PowExp,loss="WLS")
Fit1 <- optim(par=c(1,1,1),
gac_obj,
method = "L-BFGS-B",
lower=c(0,0,0),
upper = c(Inf,Inf,2),
R=R,Emp_Cov = Cov_R_sim,
cov_func=Spherical)
Cov_R_fit <- PowExp(R,params =  Fit1$par)
plot(c(R),c(Cov_R_sim),pch=16,col=rgb(0,1,0,alpha = .1))
points(c(R),c(Cov_R),pch=16)
points(c(R),c(Cov_R_fit),pch=16,col=2)
# Remove everything apart from functions
rm(list = setdiff(ls(), lsf.str()))
## Example with changing parameter ####
require(Matrix)
r <- seq(0,1,length.out=100)
R <- as.matrix(dist(r))
Z <- r %*% t(r) # NB: Cov is no longer a function of separation only...
image(t(Z))
# True Covariance
Cov_R <- as.matrix(nearPD(PowExp(R,params = list(sigma=sqrt(2),theta=2+1/(0.2+Z),gamm=1)))$mat)
image(t(Cov_R))
# Empirical from simulation
data_sim <- mvnfast::rmvn(n = 2^11,mu=rep(0,ncol(Cov_R)),sigma = Cov_R)
Cov_R_sim <- cov(data_sim)
image(t(Cov_R_sim))
modelling_table <- data.frame(y=c(Cov_R_sim),
r=c(R),
x1=c(Z))
plot(x=modelling_table$r,
y=modelling_table$y,
col=rgb(1-modelling_table$x1,0,modelling_table$x1))
test_fit <- gac(R = R,
X = list(x1=Z),
Emp_Cov = Cov_R_sim,
cov_func = PowExp,
param_eqns = list(~1,
~bs(x1,df=5,intercept = F),
~1),
loss="WLS")
rm(list=ls())
require(rstudioapi)
require(data.table)
require(plot3D)
require(plot3Drgl)
require(mvnfast)
require(splines)
require(roxygen2)
require(devtools)
setwd(dirname(getActiveDocumentContext()$path))
# Update package documentation
document(pkg = ".")
# Install from local repository
install(".")
# Load Package
require(gac)
## Notes for the future ####
# Try nls()... e.g. formula = cov ~ cov_function(...)
# End goal: estimate and sample mvn. This script focuses on estimating
# parametric contrivance functions.
# Alternative, estimate (sparse) precision matrix e.g. "glasso" then
# sample using "sparseMVN::rmvn.sparse()"...
## Form single-variate symmetric matrix, sample and fit  ####
r <- seq(0,3,by=0.1)
R <- as.matrix(dist(r))
Cov_R <- PowExp(R,params = c(sqrt(2),1.5,0.8))
# Cov_R <- Spherical(R)
image(t(Cov_R))
surf3D(matrix(r,length(r),length(r),byrow = F),
matrix(r,length(r),length(r),byrow = T),
Cov_R,
colvar = Cov_R, colkey = F, facets = F,bty="f",
xlab="Lead-time",ylab="Lead-time",zlab="Covariance",
zlim=c(0,1),theta = -10,phi = 10)
# plotrgl()
## Visualisations
# r <- seq(0,3,by=0.01)
# plot(r,PowExp(r),type="l",ylim = c(0,1.1))
# lines(r,Whittle_Matern(r),col=2)
# lines(r,Cauchy(r),col=3)
# lines(r,Spherical(r,theta = 2),col=4)
## Sample
data_sim <- mvnfast::rmvn(n = 2^11,mu=rep(0,ncol(Cov_R)),sigma = Cov_R)
Cov_R_sim <- cov(data_sim)
image(t(Cov_R_sim))
image(t(Cov_R_sim-Cov_R))
gac_obj(c(1,1,1),R,Cov_R_sim,cov_func=PowExp,loss="WLS")
Fit1 <- optim(par=c(1,1,1),
gac_obj,
method = "L-BFGS-B",
lower=c(0,0,0),
upper = c(Inf,Inf,2),
R=R,Emp_Cov = Cov_R_sim,
cov_func=Spherical)
Cov_R_fit <- PowExp(R,params =  Fit1$par)
plot(c(R),c(Cov_R_sim),pch=16,col=rgb(0,1,0,alpha = .1))
points(c(R),c(Cov_R),pch=16)
points(c(R),c(Cov_R_fit),pch=16,col=2)
# Remove everything apart from functions
rm(list = setdiff(ls(), lsf.str()))
## Example with changing parameter ####
require(Matrix)
r <- seq(0,1,length.out=100)
R <- as.matrix(dist(r))
Z <- r %*% t(r) # NB: Cov is no longer a function of separation only...
image(t(Z))
# True Covariance
Cov_R <- as.matrix(nearPD(PowExp(R,params = list(sigma=sqrt(2),theta=2+1/(0.2+Z),gamm=1)))$mat)
image(t(Cov_R))
# Empirical from simulation
data_sim <- mvnfast::rmvn(n = 2^11,mu=rep(0,ncol(Cov_R)),sigma = Cov_R)
Cov_R_sim <- cov(data_sim)
image(t(Cov_R_sim))
modelling_table <- data.frame(y=c(Cov_R_sim),
r=c(R),
x1=c(Z))
plot(x=modelling_table$r,
y=modelling_table$y,
col=rgb(1-modelling_table$x1,0,modelling_table$x1))
test_fit <- gac(R = R,
X = list(x1=Z),
Emp_Cov = Cov_R_sim,
cov_func = PowExp,
param_eqns = list(~1,
~bs(x1,df=5,intercept = F),
~1),
loss="WLS")
#' Objective functions for covariance functions
#'
#' Function to evaluate a selected objective function for a given covariance
#' function and empirical covairance function.
#'
#' @author Jethro Browell, \email{jethro.browell@@glasgow.ac.uk}
#' @param params A list of parameters to be passed to specified covairance function \code{cov_func}
#' @param R Separation matrix (or vector)
#' @param Emp_Cov Empirical covariance matrix against which covariance function is evaluated
#' @param cov_func A covariance function
#' @param loss Chosen loss function. Options are:
#' \itemize{
#'  \item{"WLS"}{Weighted Leased Squares - weigthing by correlation.}
#'  \item{"LS"}{Least Squares}
#' }
#' @details Function that returns the value of the chosen loss function for given
#' empirical covariance matrix and covairance function for use in numerical methods.
#' @keywords Covariance Function
#' @export
gac_obj <- function(params,R,Emp_Cov,cov_func,loss="WLS",...){
# Calculate parametric covairance matrix from supplied parameters
Par_cov <- cov_func(r = R,params,...)
if(loss=="WLS"){
# Weighted least squares of covariance only (VARIANCE excluded!)
mean(((Emp_Cov-Par_cov)/abs(1-cov2cor(Par_cov)))[R!=0]^2)
}else if(loss=="LS"){
# Least squares (including variance)
mean((Emp_Cov-Par_cov))^2
}else{
stop("Loss not recognised.")
}
}
#
# Need to add smoothness parameter - ridge penalty
#
#' Generalised Additive Covariance Functions
#'
#' Function to fit a covairance function with generalised additive-type models
#' for parameters.
#'
#' @author Jethro Browell, \email{jethro.browell@@glasgow.ac.uk}
#' @param params R Separation matrix
#' @param X Some container of covariates, e.g. a list with elements same size as \code{R}
#' @param Emp_CovEmpirical covaraiance to fit model to
#' @param cov_func A parametric covarianve function
#' @param param_eqns A list of equations for each parameter of \code{cov_func}
#' @param param_init Parameter values to initialise optimisaion
#' @param loss Chosen loss function. Options are:
#' \itemize{
#'  \item{"WLS"}{Weighted Leased Squares - weigthing by correlation.}
#'  \item{"LS"}{Least Squares}
#' }
#' @details Fits models for generalised additive covariance functions. Work in progress!
#' @return Returns an object of class \code{gac} for which methods will be writtern...
#' @keywords Covariance Function
#' @export
gac <- function(R,
X,
Emp_Cov,
cov_func,
param_eqns,
param_init=NULL,
loss="WLS"){
## Create modeling table of expanded basis from param_equations
modelling_table <- data.frame(y=c(Emp_Cov),
r=c(R))
design_mat <- list()
for(i in names(X)){
modelling_table[[i]] <- c(X[[i]])
}
for(i in 1:length(param_eqns)){
design_mat[[i]] <- model.matrix(param_eqns[[i]],data = modelling_table)
}
## Create objective function for model parameters ~ need some penalty on smoothness?
internal_gac_obj <- function(gac_coef,design_mat,R,Emp_Cov,cov_func,loss){
# Calculate parametric covairance matrix from supplied parameters and equations/design matrix
n_gac_coef <- unlist(lapply(design_mat,ncol))
params <- list()
for(i in 1:length(design_mat)){
params[[i]] <-  matrix(design_mat[[i]] %*% gac_coef[
sum(n_gac_coef[0:(i-1)])+1:n_gac_coef[i]],
ncol = ncol(R))
}
gac_obj(params = params,R = R,Emp_Cov = Emp_Cov,cov_func = cov_func,loss=loss,optim_bound=T)
}
## Estimate parameters
# Prep initial values
if(is.null(param_init)){
param_init <- rep(1,length(param_eqns))
}
gac_coef_init <- c()
for(i in 1:length(design_mat)){
gac_coef_init <- c(gac_coef_init,param_init[i],rep(0,ncol(design_mat[[i]])-1))
}
# Check first evaluation...
temp_test <- try(internal_gac_obj(gac_coef = gac_coef_init,design_mat = design_mat,
R = R,Emp_Cov = Emp_Cov,cov_func = cov_func))
if(class(temp_test)=="try.error"){stop("First evaluation of objective function (with param_init) failed.")}
rm(temp_test)
# Perform optimisation...
Fit1 <- optim(par = gac_coef_init,
fn = internal_gac_obj,
design_mat = design_mat,
R = R,
Emp_Cov = Emp_Cov,
cov_func = cov_func,
loss = loss,
method = "BFGS")
## Return as "gac" class
param_est <- list()
gac_coef <- list()
n_gac_coef <- unlist(lapply(design_mat,ncol))
for(i in 1:length(design_mat)){
gac_coef[[i]] <- Fit1$par[sum(n_gac_coef[0:(i-1)])+1:n_gac_coef[i]]
param_est[[i]] <-  matrix(design_mat[[i]] %*% gac_coef[[i]],ncol = ncol(R))
}
output <- list(call=match.call(),
Cov_Est = cov_func(r=R,params = param_est),
param_est=param_est,
gac_coef=gac_coef)
class(output) <- "gac"
return(output)
}
test_fit <- gac(R = R,
X = list(x1=Z),
Emp_Cov = Cov_R_sim,
cov_func = PowExp,
param_eqns = list(~1,
~bs(x1,df=5,intercept = F),
~1),
loss="WLS")
rm(list=ls())
rm(list=ls())
require(rstudioapi)
require(data.table)
require(plot3D)
require(plot3Drgl)
require(mvnfast)
require(splines)
require(roxygen2)
require(devtools)
setwd(dirname(getActiveDocumentContext()$path))
# Update package documentation
document(pkg = ".")
# Install from local repository
install(".")
# Install from local repository
install(".")
# Update package documentation
document(pkg = ".")
# Update package documentation
document(pkg = ".")
# Install from local repository
install(".")
# Update package documentation
document(pkg = ".")
# Update package documentation
document(pkg = ".")
# Install from local repository
install(".")
?loss
# Update package documentation
document(pkg = ".")
# Update package documentation
document(pkg = ".")
# Install from local repository
install(".")
# Update package documentation
document(pkg = ".")
# Install from local repository
install(".")
# Update package documentation
document(pkg = ".")
# Update package documentation
document(pkg = ".")
# Install from local repository
install(".")
# Update package documentation
document(pkg = ".")
# Update package documentation
document(pkg = ".")
# Update package documentation
document(pkg = ".")
# Install from local repository
install(".")
rm(list=ls())
require(rstudioapi)
require(data.table)
require(plot3D)
require(plot3Drgl)
require(mvnfast)
require(splines)
require(roxygen2)
require(devtools)
setwd(dirname(getActiveDocumentContext()$path))
# Update package documentation
document(pkg = ".")
# Update package documentation
document(pkg = ".")
# Update package documentation
document(pkg = ".")
# Install from local repository
install(".")
# Update package documentation
document(pkg = ".")
# Update package documentation
document(pkg = ".")
# Install from local repository
install(".")
# Update package documentation
document(pkg = ".")
# Update package documentation
document(pkg = ".")
# Install from local repository
install(".")
# Update package documentation
document(pkg = ".")
# Update package documentation
document(pkg = ".")
# Install from local repository
install(".")
# Update package documentation
document(pkg = ".")
# Install from local repository
install(".")
