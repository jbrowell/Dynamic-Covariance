gam(formula = param_eqns[[i]],
data=modelling_table,
fit = F)
for(i in 1:length(param_eqns)){
gam(formula = param_eqns[[i]],
data=modelling_table,
fit = F)
}
param_eqns[[i]]
gam(formula = y~1,
data=modelling_table,
fit = F)
?update
update(~1,y.)
update(~1,y~)
update("~1","y~")
update(~1,~+a)
update(~1,y~.)
update(~1+s(x),y~.)
temp_gam <- gam(formula = update(param_eqns[[i]],y~.),
data=modelling_table,
fit = F)
temp_gam
update(y~x,z~.)
i=2
temp_gam <- gam(formula = update(param_eqns[[i]],y~.),
data=modelling_table,
fit = F)
temp_gam
predict.gam(temp_gam,type = "terms")
temp_gam <- gam(formula = update(param_eqns[[i]],y~.),
data=modelling_table,
fit = F)
temp_gam
terms(temp_gam)
predict(temp_gam,type = "terms")
PredictMat(temp_gam,type = "terms")
PredictMat(temp_gam)
PredictMat(temp_gam,data=modelling_table)
Predict.matrix(temp_gam,data=modelling_table)
predict.matrix(temp_gam,data=modelling_table)
require(splines)
param_eqns <- list(~1,
~bs(x1,df=5,intercept = T),
~1)
?bs
update(param_eqns[[i]],y~.)
model.frame(update(param_eqns[[i]],y~.))
model.frame(update(param_eqns[[i]],y~.),data = modelling_table)
design_mat[[i]] <- model.frame(update(param_eqns[[i]],y~.),data = modelling_table)
design_mat <- list()
## For dev:
R <- R
X <- list(x1=Z)
Emp_Cov <- Cov_R_sim
cov_func <- PowExp
param_eqns <- list(~1,
~bs(x1,df=5,intercept = T),
~1)
## Create modeling table of expanded basis from param_equations
modelling_table <- data.frame(y=c(Cov_R_sim),
r=c(R))
design_mat <- list()
for(i in names(X)){
modelling_table[[i]] <- c(X[[i]])
}
for(i in 1:length(param_eqns)){
# temp_gam <- gam(formula = update(param_eqns[[i]],y~.),
#                 data=modelling_table,
#                 fit = F)
design_mat[[i]] <- model.frame(update(param_eqns[[i]],y~.),data = modelling_table)
}
design_mat
design_mat[[1]]
?model.frame
?nls
design_mat[[i]] <- model.matrix(update(param_eqns[[i]],y~.),data = modelling_table)
model.matrix(update(param_eqns[[i]],y~.),data = modelling_table)
for(i in 1:length(param_eqns)){
# temp_gam <- gam(formula = update(param_eqns[[i]],y~.),
#                 data=modelling_table,
#                 fit = F)
design_mat[[i]] <- model.matrix(update(param_eqns[[i]],y~.),data = modelling_table)
}
design_mat[[2]]
head(design_mat[[2]])
param_eqns <- list(~1,
~bs(x1,df=5,intercept = F),
~1)
## Create modeling table of expanded basis from param_equations
modelling_table <- data.frame(y=c(Cov_R_sim),
r=c(R))
design_mat <- list()
for(i in names(X)){
modelling_table[[i]] <- c(X[[i]])
}
for(i in 1:length(param_eqns)){
# temp_gam <- gam(formula = update(param_eqns[[i]],y~.),
#                 data=modelling_table,
#                 fit = F)
design_mat[[i]] <- model.matrix(update(param_eqns[[i]],y~.),data = modelling_table)
}
head(design_mat[[2]])
plot(design_mat[[2]][,1])
plot(design_mat[[2]][,2])
plot(design_mat[[2]][,3])
plot(design_mat[[2]][,4])
for(i in 1:length(param_eqns)){
# temp_gam <- gam(formula = update(param_eqns[[i]],y~.),
#                 data=modelling_table,
#                 fit = F)
design_mat[[i]] <- model.matrix(update(param_eqns[[i]],y~.),data = modelling_table)
}
design_mat[[i]] <- model.matrix(param_eqns[[i]],data = modelling_table)
for(i in 1:length(param_eqns)){
# temp_gam <- gam(formula = update(param_eqns[[i]],y~.),
#                 data=modelling_table,
#                 fit = F)
design_mat[[i]] <- model.matrix(param_eqns[[i]],data = modelling_table)
}
head(design_mat[[i]][2])
head(design_mat[[2]])
## Create objective function for model parameters ~ need some penalty on smoothness?
obj <- function(gac_params,design_mat,R,Emp_Cov,cov_func,loss="WLS"){
# Calculate parametric covairance matrix from supplied parameters
for(i in 1:length(design_mat)){
params[[i]] <-  gac_params[[i]] %*% design_mat[[i]]
}
Par_cov <- cov_func(r = R,params)
if(loss=="WLS"){
# Weighted least squares of covariance only (VARIANCE excluded!)
mean(((Emp_Cov-Par_cov)/abs(1-cov2cor(Par_cov)))[R!=0]^2)
}else if(loss=="LS"){
# Least squares (including variance)
mean((Emp_Cov-Par_cov))^2
}else{
stop("Loss not recognised.")
}
}
obj <- function(params,R,Emp_Cov,cov_func,loss="WLS"){
# Calculate parametric covairance matrix from supplied parameters
Par_cov <- cov_func(r = R,params)
if(loss=="WLS"){
# Weighted least squares of covariance only (VARIANCE excluded!)
mean(((Emp_Cov-Par_cov)/abs(1-cov2cor(Par_cov)))[R!=0]^2)
}else if(loss=="LS"){
# Least squares (including variance)
mean((Emp_Cov-Par_cov))^2
}else{
stop("Loss not recognised.")
}
}
## Create objective function for model parameters ~ need some penalty on smoothness?
obj_gac <- function(gac_params,design_mat,R,Emp_Cov,cov_func,loss="WLS"){
# Calculate parametric covairance matrix from supplied parameters
for(i in 1:length(design_mat)){
params[[i]] <-  gac_params[[i]] %*% design_mat[[i]]
}
obj(params = params,R = R,Emp_Cov = Emp_Cov,cov_func = cov_func,loss=loss)
}
rm(list=ls())
rm(list=ls())
require(rstudioapi)
require(data.table)
require(plot3D)
require(plot3Drgl)
require(mvnfast)
setwd(dirname(getActiveDocumentContext()$path))
source("CovFunctions.R")
## Notes for the future ####
# Try nls()... e.g. formula = cov ~ cov_function(...)
# End goal: estimate and sample mvn. This script focuses on estimating
# parametric contrivance functions.
# Alternative, estimate (sparse) precision matrix e.g. "glasso" then
# sample using "sparseMVN::rmvn.sparse()"...
## Form single-variate symmetric matrix, sample and fit  ####
r <- seq(0,3,by=0.1)
R <- as.matrix(dist(r))
Cov_R <- PowExp(R,params = c(sqrt(2),1.5,0.8))
# Cov_R <- Spherical(R)
image(t(Cov_R))
surf3D(matrix(r,length(r),length(r),byrow = F),
matrix(r,length(r),length(r),byrow = T),
Cov_R,
colvar = Cov_R, colkey = F, facets = F,bty="f",
xlab="Lead-time",ylab="Lead-time",zlab="Covariance",
zlim=c(0,1),theta = -10,phi = 10)
data_sim <- mvnfast::rmvn(n = 2^11,mu=rep(0,ncol(Cov_R)),sigma = Cov_R)
Cov_R_sim <- cov(data_sim)
image(t(Cov_R_sim))
image(t(Cov_R_sim-Cov_R))
obj <- function(params,R,Emp_Cov,cov_func,loss="WLS"){
# Calculate parametric covairance matrix from supplied parameters
Par_cov <- cov_func(r = R,params)
if(loss=="WLS"){
# Weighted least squares of covariance only (VARIANCE excluded!)
mean(((Emp_Cov-Par_cov)/abs(1-cov2cor(Par_cov)))[R!=0]^2)
}else if(loss=="LS"){
# Least squares (including variance)
mean((Emp_Cov-Par_cov))^2
}else{
stop("Loss not recognised.")
}
}
obj(c(1,1),R,Cov_R_sim,cov_func=Spherical)
Fit1 <- optim(par=c(1,1),
obj,
method = "L-BFGS-B",
lower=c(0,0,0),
upper = c(Inf,Inf,2),
R=R,Emp_Cov = Cov_R_sim,
cov_func=Spherical)
Cov_R_fit <- Spherical(R,params =  Fit1$par)
plot(c(R),c(Cov_R_sim),pch=16,col=rgb(0,1,0,alpha = .1))
points(c(R),c(Cov_R),pch=16)
obj(c(1,1),R,Cov_R_sim,cov_func=PowExp())
obj(c(1,1,1),R,Cov_R_sim,cov_func=PowExp())
obj(c(1,1,1),R,Cov_R_sim,cov_func=PowExp
)
obj(c(1,1),R,Cov_R_sim,cov_func=PowExp)
obj(c(1,1,1),R,Cov_R_sim,cov_func=PowExp)
Fit1 <- optim(par=c(1,1,1),
obj,
method = "L-BFGS-B",
lower=c(0,0,0),
upper = c(Inf,Inf,2),
R=R,Emp_Cov = Cov_R_sim,
cov_func=Spherical)
Cov_R_fit <- Spherical(R,params =  Fit1$par)
Cov_R_fit <- PowExp(R,params =  Fit1$par)
plot(c(R),c(Cov_R_sim),pch=16,col=rgb(0,1,0,alpha = .1))
points(c(R),c(Cov_R),pch=16)
points(c(R),c(Cov_R_fit),pch=16,col=2)
# Remove everything apart from functions
rm(list = setdiff(ls(), lsf.str()))
## Example with changing parameter ####
require(mgcv)
require(Matrix)
r <- seq(0,1,length.out=100)
R <- as.matrix(dist(r))
Z <- r %*% t(r) # NB: Cov is no longer a function of separation only...
image(t(Z))
# True Covariance
Cov_R <- as.matrix(nearPD(PowExp(R,params = list(sigma=sqrt(2),theta=2+1/(0.2+Z),gamm=1)))$mat)
image(t(Cov_R))
# Empirical from simulation
data_sim <- mvnfast::rmvn(n = 2^11,mu=rep(0,ncol(Cov_R)),sigma = Cov_R)
Cov_R_sim <- cov(data_sim)
image(t(Cov_R_sim))
modelling_table <- data.frame(y=c(Cov_R_sim),
r=c(R),
x1=c(Z))
plot(x=modelling_table$r,
y=modelling_table$y,
col=rgb(1-modelling_table$x1,0,modelling_table$x1))
## For dev:
R <- R
X <- list(x1=Z)
Emp_Cov <- Cov_R_sim
cov_func <- PowExp
param_eqns <- list(~1,
~bs(x1,df=5,intercept = F),
~1)
## Create modeling table of expanded basis from param_equations
modelling_table <- data.frame(y=c(Cov_R_sim),
r=c(R))
design_mat <- list()
param_init <- rep(1,length(param_eqns))
param_init
## Estimate parameters
if(is.null(param_init)){
param_init <- rep(1,length(param_eqns))
}
gac_params_init <- list()
for(i in 1:length(design_mat)){
gac_params_init[[i]] <- c(param_init[i],rep(0,ncol(design_mat[[i]]-1)))
}
design_mat
## Create modeling table of expanded basis from param_equations
modelling_table <- data.frame(y=c(Cov_R_sim),
r=c(R))
design_mat <- list()
for(i in names(X)){
modelling_table[[i]] <- c(X[[i]])
}
for(i in 1:length(param_eqns)){
# temp_gam <- gam(formula = update(param_eqns[[i]],y~.),
#                 data=modelling_table,
#                 fit = F)
design_mat[[i]] <- model.matrix(param_eqns[[i]],data = modelling_table)
}
## For dev:
R <- R
X <- list(x1=Z)
Emp_Cov <- Cov_R_sim
cov_func <- PowExp
param_eqns <- list(~1,
~bs(x1,df=5,intercept = F),
~1)
## Create modeling table of expanded basis from param_equations
modelling_table <- data.frame(y=c(Cov_R_sim),
r=c(R))
design_mat <- list()
for(i in names(X)){
modelling_table[[i]] <- c(X[[i]])
}
for(i in 1:length(param_eqns)){
# temp_gam <- gam(formula = update(param_eqns[[i]],y~.),
#                 data=modelling_table,
#                 fit = F)
design_mat[[i]] <- model.matrix(param_eqns[[i]],data = modelling_table)
}
## Create objective function for model parameters ~ need some penalty on smoothness?
obj_gac <- function(gac_params,design_mat,R,Emp_Cov,cov_func,loss="WLS"){
# Calculate parametric covairance matrix from supplied parameters
for(i in 1:length(design_mat)){
params[[i]] <-  gac_params[[i]] %*% design_mat[[i]]
}
obj(params = params,R = R,Emp_Cov = Emp_Cov,cov_func = cov_func,loss=loss)
}
## Estimate parameters
if(is.null(param_init)){
param_init <- rep(1,length(param_eqns))
}
gac_params_init <- list()
for(i in 1:length(design_mat)){
gac_params_init[[i]] <- c(param_init[i],rep(0,ncol(design_mat[[i]]-1)))
}
gac_params_init
design_mat[[1]]
head(design_mat[[1]])
length(design_mat[[1]])
ncol(design_mat[[1]])
rep(0,0)
gac_params_init <- list()
for(i in 1:length(design_mat)){
gac_params_init[[i]] <- c(param_init[i],rep(0,ncol(design_mat[[i]])-1))
}
gac_params_init
obj_gac(gac_params = gac_params_init,design_mat = design_mat)
## Create objective function for model parameters ~ need some penalty on smoothness?
obj_gac <- function(gac_params,design_mat,R,Emp_Cov,cov_func,loss="WLS"){
# Calculate parametric covairance matrix from supplied parameters
for(i in 1:length(design_mat)){
params[[i]] <-  design_mat[[i]] %*% gac_params[[i]]
}
obj(params = params,R = R,Emp_Cov = Emp_Cov,cov_func = cov_func,loss=loss)
}
## Estimate parameters
if(is.null(param_init)){
param_init <- rep(1,length(param_eqns))
}
gac_params_init <- list()
for(i in 1:length(design_mat)){
gac_params_init[[i]] <- c(param_init[i],rep(0,ncol(design_mat[[i]])-1))
}
obj_gac(gac_params = gac_params_init,design_mat = design_mat)
## Create objective function for model parameters ~ need some penalty on smoothness?
obj_gac <- function(gac_params,design_mat,R,Emp_Cov,cov_func,loss="WLS"){
# Calculate parametric covairance matrix from supplied parameters
params <- list()
for(i in 1:length(design_mat)){
params[[i]] <-  design_mat[[i]] %*% gac_params[[i]]
}
obj(params = params,R = R,Emp_Cov = Emp_Cov,cov_func = cov_func,loss=loss)
}
## Estimate parameters
if(is.null(param_init)){
param_init <- rep(1,length(param_eqns))
}
gac_params_init <- list()
for(i in 1:length(design_mat)){
gac_params_init[[i]] <- c(param_init[i],rep(0,ncol(design_mat[[i]])-1))
}
obj_gac(gac_params = gac_params_init,design_mat = design_mat)
## Create objective function for model parameters ~ need some penalty on smoothness?
obj_gac <- function(gac_params,design_mat,R,Emp_Cov,cov_func=cov_func,loss="WLS"){
# Calculate parametric covairance matrix from supplied parameters
params <- list()
for(i in 1:length(design_mat)){
params[[i]] <-  design_mat[[i]] %*% gac_params[[i]]
}
obj(params = params,R = R,Emp_Cov = Emp_Cov,cov_func = cov_func,loss=loss)
}
## Estimate parameters
if(is.null(param_init)){
param_init <- rep(1,length(param_eqns))
}
gac_params_init <- list()
for(i in 1:length(design_mat)){
gac_params_init[[i]] <- c(param_init[i],rep(0,ncol(design_mat[[i]])-1))
}
obj_gac(gac_params = gac_params_init,design_mat = design_mat)
## Create objective function for model parameters ~ need some penalty on smoothness?
obj_gac <- function(gac_params,design_mat,R=R,Emp_Cov=Emp_Cov,cov_func=cov_func,loss="WLS"){
# Calculate parametric covairance matrix from supplied parameters
params <- list()
for(i in 1:length(design_mat)){
params[[i]] <-  design_mat[[i]] %*% gac_params[[i]]
}
obj(params = params,R = R,Emp_Cov = Emp_Cov,cov_func = cov_func,loss=loss)
}
obj_gac(gac_params = gac_params_init,design_mat = design_mat)
## For dev:
R <- R
X <- list(x1=Z)
Emp_Cov <- Cov_R_sim
cov_func <- PowExp
param_eqns <- list(~1,
~bs(x1,df=5,intercept = F),
~1)
## Create modeling table of expanded basis from param_equations
modelling_table <- data.frame(y=c(Cov_R_sim),
r=c(R))
design_mat <- list()
for(i in names(X)){
modelling_table[[i]] <- c(X[[i]])
}
for(i in 1:length(param_eqns)){
# temp_gam <- gam(formula = update(param_eqns[[i]],y~.),
#                 data=modelling_table,
#                 fit = F)
design_mat[[i]] <- model.matrix(param_eqns[[i]],data = modelling_table)
}
## Create objective function for model parameters ~ need some penalty on smoothness?
obj_gac <- function(gac_params,design_mat,R,Emp_Cov,cov_func,loss="WLS"){
# Calculate parametric covairance matrix from supplied parameters
params <- list()
for(i in 1:length(design_mat)){
params[[i]] <-  design_mat[[i]] %*% gac_params[[i]]
}
obj(params = params,R = R,Emp_Cov = Emp_Cov,cov_func = cov_func,loss=loss)
}
obj_gac(gac_params = gac_params_init,design_mat = design_mat,
R = R,Emp_Cov = Emp_Cov,cov_func = cov_func)
R
obj_gac(gac_params = gac_params_init,design_mat = design_mat,
R = R,Emp_Cov = Emp_Cov,cov_func = cov_func)
## Create objective function for model parameters ~ need some penalty on smoothness?
obj_gac <- function(gac_params,design_mat,R,Emp_Cov,cov_func,loss="WLS"){
# Calculate parametric covairance matrix from supplied parameters
params <- list()
for(i in 1:length(design_mat)){
params[[i]] <-  design_mat[[i]] %*% gac_params[[i]]
}
obj(params = params,R = c(R),Emp_Cov = Emp_Cov,cov_func = cov_func,loss=loss)
}
obj_gac(gac_params = gac_params_init,design_mat = design_mat,
R = R,Emp_Cov = Emp_Cov,cov_func = cov_func)
## Create objective function for model parameters ~ need some penalty on smoothness?
obj_gac <- function(gac_params,design_mat,R,Emp_Cov,cov_func,loss="WLS"){
# Calculate parametric covairance matrix from supplied parameters
params <- list()
for(i in 1:length(design_mat)){
params[[i]] <-  matrix(design_mat[[i]] %*% gac_params[[i]],ncol = ncol(R))
}
obj(params = params,R = R,Emp_Cov = Emp_Cov,cov_func = cov_func,loss=loss)
}
## Estimate parameters
if(is.null(param_init)){
param_init <- rep(1,length(param_eqns))
}
gac_params_init <- list()
for(i in 1:length(design_mat)){
gac_params_init[[i]] <- c(param_init[i],rep(0,ncol(design_mat[[i]])-1))
}
obj_gac(gac_params = gac_params_init,design_mat = design_mat,
R = R,Emp_Cov = Emp_Cov,cov_func = cov_func)
c(1,2,3,4)
matrix(c(1,2,3,4),ncol=2)
c(matrix(c(1,2,3,4),ncol=2))
try(obj_gac(gac_params = gac_params_init,design_mat = design_mat,
R = R,Emp_Cov = Emp_Cov,cov_func = cov_func))
tryCatch(obj_gac(gac_params = gac_params_init,design_mat = design_mat,
R = R,Emp_Cov = Emp_Cov,cov_func = cov_func))
?tryCatch
tryCatch(obj_gac(gac_params = gac_params_init,design_mat = design_mat,
R = R,Emp_Cov = Emp_Cov,cov_func = cov_func),finally = print("Hello"))
tryCatch(obj_gac(gac_params = gac_params_init,design_mat = design_mat,
R = R,Emp_Cov = Emp_Cov,cov_func = cov_func),
error="First evaluation of objective function (with param_init) failed.")
tryCatch(obj_gac(gac_params = gac_params_init[-1],design_mat = design_mat,
R = R,Emp_Cov = Emp_Cov,cov_func = cov_func),
error="First evaluation of objective function (with param_init) failed.")
tryCatch(obj_gac(gac_params = gac_params_init[[1]],design_mat = design_mat,
R = R,Emp_Cov = Emp_Cov,cov_func = cov_func),
error="First evaluation of objective function (with param_init) failed.")
tryCatch(obj_gac(gac_params = gac_params_init,design_mat = design_mat,
R = R,Emp_Cov = Emp_Cov,cov_func = cov_func),
error="First evaluation of objective function (with param_init) failed.")
simpleError("Error")
stop(1)
stop(simpleError("Error"))
test1 <- try(obj_gac(gac_params = gac_params_init,design_mat = design_mat,
R = R,Emp_Cov = Emp_Cov,cov_func = cov_func))
test1
test1 <- try(obj_gac(gac_params = gac_params_init[1],design_mat = design_mat,
R = R,Emp_Cov = Emp_Cov,cov_func = cov_func))
test1 <- try(obj_gac(gac_params = gac_params_init[[1]],design_mat = design_mat,
R = R,Emp_Cov = Emp_Cov,cov_func = cov_func))
test1
if(test1=="try.error"){stop("First evaluation of objective function (with param_init) failed.")}
attr(test1)
class(test1)
test1 <- try(obj_gac(gac_params = gac_params_init[[1]],design_mat = design_mat,
R = R,Emp_Cov = Emp_Cov,cov_func = cov_func))
if(class(test1)=="try.error"){stop("First evaluation of objective function (with param_init) failed.")}
test1 <- try(obj_gac(gac_params = gac_params_init,design_mat = design_mat,
R = R,Emp_Cov = Emp_Cov,cov_func = cov_func))
if(class(test1)=="try.error"){stop("First evaluation of objective function (with param_init) failed.")}
class(test1)
rm(test1)
