for(i in names(X)){
# if(all(dim(X[[i]]==dim(R)))){
if(length(X[[i]])==length(R)){
# Static component
modelling_table[[i]] <- c(X[[i]])
}else if(!is.na(data)){
# Dynamic component
if(length(X[[i]]!=nrow(data))){stop(paste("Length of covarite",i,"does not match data"))}
modelling_table[[i]] <- rep(NA,length(R))
dyn_covariates <- c(dyn_covariates,i)
}
}
for(i in 1:length(param_eqns)){
# design_mat[[i]] <- model.matrix(param_eqns[[i]],data = modelling_table)
gam_prefit <- gam(update(param_eqns[[i]],"y~."),data = modelling_table,fit = F)
design_mat[[i]] <- gam_prefit$X
# Penalty matrix
pen_mat[[i]] <- gam_prefit$S
}
## Create objective function for model parameters ~ need some penalty on smoothness?
internal_gac_obj <- function(gac_coef){#,design_mat,R,Emp_Cov,cov_func){
n_gac_coef <- unlist(lapply(design_mat,ncol))
## Smoothness penalty?
penalty <- 0
for(i in 1:length(design_mat)){
if(length(pen_mat[[i]])==0){next}
pen_dim <- cumsum(c(0,sapply(pen_mat[[i]],ncol)))
temp_coef <- gac_coef[sum(n_gac_coef[0:(i-1)])+1:n_gac_coef[i]][colnames(design_mat[[i]])!="(Intercept)"]
for(j in 1:length(pen_mat[[i]])){
temp_coef2 <- temp_coef[1:ncol(pen_mat[[i]][[j]])+pen_dim[j]]
penalty <- penalty + t(temp_coef2) %*% pen_mat[[i]][[j]] %*% temp_coef2
}
}
## Main loss
if(is.null(data)){
# Calculate parametric covairance matrix from supplied parameters and equations/design matrix
params <- list()
for(i in 1:length(design_mat)){
params[[i]] <-  matrix(design_mat[[i]] %*% gac_coef[
sum(n_gac_coef[0:(i-1)])+1:n_gac_coef[i]],
ncol = ncol(R))
}
# Value to return:
gac_obj(params = params,R = R,Emp_Cov = Emp_Cov,cov_func = cov_func,loss = loss,
optim_bound=T,pen=penalty*smoothness_param)
}else{
obj_vlaue <- rep(NA,nrow(data))
E_after_j <- matrix(0,nrow(R),ncol(R))
for(j in 1:nrow(data)){
params <- list()
for(i in 1:length(design_mat)){
# Add covariate for current row [j] of data
for(k in which(dyn_covariates %in% colnames(design_mat[[i]]))){
design_mat[[i]][dyn_covariates[k]] <- rep(X[[k]][j],length(R))
}
params[[i]] <-  matrix(design_mat[[i]] %*% gac_coef[
sum(n_gac_coef[0:(i-1)])+1:n_gac_coef[i]],
ncol = ncol(R))
}
Par_cov <- cov_func(r=R,params = params,optim_bound=T)
if(loss=="LS"){
E_after_j <- E_after_j + data[j,] %*% t(data[j,]) - Par_cov
}else{
stop("Only loss=\"LS\" available if data!=NULL")
}
}
## Least Squares
obj_vlaue <- sum((E_after_j/j)^2)
# Value to return:
print(obj_vlaue)
obj_vlaue + penalty*smoothness_param
}
}
## Estimate parameters
# Prep initial values
if(is.null(param_init)){
param_init <- rep(1,length(param_eqns))
}
gac_coef_init <- c()
for(i in 1:length(design_mat)){
gac_coef_init <- c(gac_coef_init,param_init[i],rep(0,ncol(design_mat[[i]])-1))
}
# Check first evaluation...
temp_test <- try(internal_gac_obj(gac_coef = gac_coef_init))#,design_mat = design_mat,
# R = R,Emp_Cov = Emp_Cov,cov_func = cov_func))
if(class(temp_test)[1]=="try.error"){stop("First evaluation of objective function (with param_init) failed.")}
rm(temp_test)
# Perform optimisation...
Fit1 <- optim(par = gac_coef_init,
fn = internal_gac_obj,
# design_mat = design_mat,
# R = R,
# Emp_Cov = Emp_Cov,
# cov_func = cov_func,
# loss = loss,
#
method = "BFGS"
# method = "Nelder-Mead",hessian = F
)
## Return as "gac" class
param_est <- list()
gac_coef <- list()
n_gac_coef <- unlist(lapply(design_mat,ncol))
penalty <- 0
for(i in 1:length(design_mat)){
gac_coef[[i]] <- Fit1$par[sum(n_gac_coef[0:(i-1)])+1:n_gac_coef[i]]
param_est[[i]] <-  matrix(design_mat[[i]] %*% gac_coef[[i]],ncol = ncol(R))
## Smoothness penalty?
if(length(pen_mat[[i]])==0){next}
pen_dim <- cumsum(c(0,sapply(pen_mat[[i]],ncol)))
temp_coef <- gac_coef[[i]][colnames(design_mat[[i]])!="(Intercept)"]
for(j in 1:length(pen_mat[[i]])){
temp_coef2 <- temp_coef[1:ncol(pen_mat[[i]][[j]])+pen_dim[j]]
penalty <- penalty + t(temp_coef2) %*% pen_mat[[i]][[j]] %*% temp_coef2
}
}
output <- list(call=match.call(),
R=R,X=X,
Cov_Est = cov_func(r=R,params = param_est),
param_est=param_est,
gac_coef=gac_coef,
loss_final = Fit1$value,
penalty = as.numeric(penalty))
class(output) <- "gac"
return(output)
}
test_static_fit <- gac(R = R,
X = list(x1=Z),
Emp_Cov = Cov_R_sim,
cov_func = PowExp,
param_eqns = list(~1,
~1,
~1),
loss="LS")
test_static_fit$gac_coef
test_static_fit
## --- Test version using sample data
test_static_fit_data <- gac(R = R,
X = list(x1=Z),
Emp_Cov = NULL,
data=data_sim,
cov_func = PowExp,
param_eqns = list(~1,
~1,
~1),
loss="LS")
test_static_fit_data
R
dimR
dim(R)
3/(24^2)
#' Objective functions for covariance functions
#'
#' Function to evaluate a selected objective function for a given covariance
#' function and empirical covairance function.
#'
#' @author Jethro Browell, \email{jethro.browell@@glasgow.ac.uk}
#' @param params A list of parameters to be passed to specified covairance function \code{cov_func}
#' @param R Separation matrix or vector
#' @param Emp_Cov Empirical covariance matrix against which covariance function is evaluated
#' @param cov_func A covariance function
#' @param loss Chosen loss function. Options are:
#' \itemize{
#'  \item{WLS}{Weighted Leased Squares - weigthing by cross-correlation}
#'  \item{WLSf}{Weighted Leased Squares - weigthing by all correlations}
#'  \item{LS}{Least Squares}
#' }
#' @param pen Additional penalty (numeric), e.g. on smoothness, added to loss
#' @param ... Additional arguments passed to \code{cov_func}
#' @details Function that returns the value of the chosen loss function for given
#' empirical covariance matrix and covairance function for use in numerical methods.
#' @keywords Covariance Function
#' @export
gac_obj <- function(params,R,Emp_Cov,cov_func,loss="WLS",pen=0,...){
# Calculate parametric covairance matrix from supplied parameters
Par_cov <- cov_func(r = R,params,...)
if(loss=="WLS"){
# Weighted least squares of covariance only (VARIANCE excluded!)
mean(((Emp_Cov-Par_cov)/abs(1-cov2cor(Par_cov)))[R!=0]^2) + pen
}else if(loss=="WLSf"){
# Weighted least squares
mean((abs(cov2cor(Par_cov))*(Emp_Cov-Par_cov))^2) + pen
}else if(loss=="LS"){
# Least squares (including variance)
mean((Emp_Cov-Par_cov)^2) + pen
}else if(loss=="AL"){
# Absolute Loss
mean(abs(Emp_Cov-Par_cov)) + pen
}else if(loss=="WALf"){
# Weighted Absolute
mean(abs(cov2cor(Par_cov))*abs(Emp_Cov-Par_cov)) + pen
}else{
stop("Loss not recognised.")
}
}
#
# Need to add smoothness parameter - ridge penalty
#
#' Generalised Additive Covariance Functions
#'
#' Function to fit a covairance function with generalised additive-type models
#' for parameters.
#'
#' @author Jethro Browell, \email{jethro.browell@@glasgow.ac.uk}
#' @param params R Separation matrix
#' @param X Some container of covariates, e.g. a list with elements same size as \code{R} or
#' the same length as \code{data}
#' @param Emp_Cov Empirical covaraiance to fit model a static model to.
#' @param data Dataset to fit dynamic covariance model to. \code{ncol(data)} must equal
#' \code{nrow(R)}
#' @param cov_func A parametric covarianve function.
#' @param param_eqns A list of equations for each parameter of \code{cov_func}
#' @param param_init Parameter values to initialise optimisaion
#' @param loss Chosen loss function. Options are:
#' \itemize{
#'  \item{WLS}{Weighted Leased Squares - weigthing by correlation}
#'  \item{WLSf}{Weighted Leased Squares - weigthing by all correlations}
#'  \item{LS}{Least Squares}
#' }
#' @param smoothness_param Parameter to control smoothness, is the weight that multiples
#' squared second derivative of smooth splines.
#' @details Fits models for generalised additive covariance functions. Work in progress!
#' @return Returns an object of class \code{gac} for which methods will be written...
#' @keywords Covariance Function
#' @export
gac <- function(R,
X=list(),
Emp_Cov=NULL,
data=NULL,
cov_func,
param_eqns,
param_init=NULL,
loss="WLS",
smoothness_param=0){
if(is.null(Emp_Cov) & is.null(data)){stop("One of Emp_Cov or data must be supplied.")}
if(!is.null(Emp_Cov)){
if(nrow(R)!=nrow(Emp_Cov) | ncol(R)!=ncol(Emp_Cov)){stop("Size of R and Emp_Cov don't match.")}
}
if(!is.null(data)){
if(!is.null(Emp_Cov)){warning("data supplied so Emp_Cov will not used.")}
Emp_Cov <- t(data) %*% data
if(nrow(R)!=ncol(R) | ncol(R)!=ncol(data)){stop("Size of R and Emp_Cov don't match.")}
}
## Create modeling table of expanded basis from param_equations
modelling_table <- data.frame(y=c(Emp_Cov),
r=c(R))
design_mat <- list()
pen_mat <- list()
dyn_covariates <- c()
for(i in names(X)){
# if(all(dim(X[[i]]==dim(R)))){
if(length(X[[i]])==length(R)){
# Static component
modelling_table[[i]] <- c(X[[i]])
}else if(!is.na(data)){
# Dynamic component
if(length(X[[i]]!=nrow(data))){stop(paste("Length of covarite",i,"does not match data"))}
modelling_table[[i]] <- rep(NA,length(R))
dyn_covariates <- c(dyn_covariates,i)
}
}
for(i in 1:length(param_eqns)){
# design_mat[[i]] <- model.matrix(param_eqns[[i]],data = modelling_table)
gam_prefit <- gam(update(param_eqns[[i]],"y~."),data = modelling_table,fit = F)
design_mat[[i]] <- gam_prefit$X
# Penalty matrix
pen_mat[[i]] <- gam_prefit$S
}
## Create objective function for model parameters ~ need some penalty on smoothness?
internal_gac_obj <- function(gac_coef){#,design_mat,R,Emp_Cov,cov_func){
n_gac_coef <- unlist(lapply(design_mat,ncol))
## Smoothness penalty?
penalty <- 0
for(i in 1:length(design_mat)){
if(length(pen_mat[[i]])==0){next}
pen_dim <- cumsum(c(0,sapply(pen_mat[[i]],ncol)))
temp_coef <- gac_coef[sum(n_gac_coef[0:(i-1)])+1:n_gac_coef[i]][colnames(design_mat[[i]])!="(Intercept)"]
for(j in 1:length(pen_mat[[i]])){
temp_coef2 <- temp_coef[1:ncol(pen_mat[[i]][[j]])+pen_dim[j]]
penalty <- penalty + t(temp_coef2) %*% pen_mat[[i]][[j]] %*% temp_coef2
}
}
## Main loss
if(is.null(data)){
# Calculate parametric covairance matrix from supplied parameters and equations/design matrix
params <- list()
for(i in 1:length(design_mat)){
params[[i]] <-  matrix(design_mat[[i]] %*% gac_coef[
sum(n_gac_coef[0:(i-1)])+1:n_gac_coef[i]],
ncol = ncol(R))
}
# Value to return:
gac_obj(params = params,R = R,Emp_Cov = Emp_Cov,cov_func = cov_func,loss = loss,
optim_bound=T,pen=penalty*smoothness_param)
}else{
obj_vlaue <- rep(NA,nrow(data))
E_after_j <- matrix(0,nrow(R),ncol(R))
for(j in 1:nrow(data)){
params <- list()
for(i in 1:length(design_mat)){
# Add covariate for current row [j] of data
for(k in which(dyn_covariates %in% colnames(design_mat[[i]]))){
design_mat[[i]][dyn_covariates[k]] <- rep(X[[k]][j],length(R))
}
params[[i]] <-  matrix(design_mat[[i]] %*% gac_coef[
sum(n_gac_coef[0:(i-1)])+1:n_gac_coef[i]],
ncol = ncol(R))
}
Par_cov <- cov_func(r=R,params = params,optim_bound=T)
if(loss=="LS"){
E_after_j <- E_after_j + data[j,] %*% t(data[j,]) - Par_cov
}else{
stop("Only loss=\"LS\" available if data!=NULL")
}
}
## Least Squares
obj_vlaue <- mean((E_after_j/j)^2)
# Value to return:
print(obj_vlaue)
obj_vlaue + penalty*smoothness_param
}
}
## Estimate parameters
# Prep initial values
if(is.null(param_init)){
param_init <- rep(1,length(param_eqns))
}
gac_coef_init <- c()
for(i in 1:length(design_mat)){
gac_coef_init <- c(gac_coef_init,param_init[i],rep(0,ncol(design_mat[[i]])-1))
}
# Check first evaluation...
temp_test <- try(internal_gac_obj(gac_coef = gac_coef_init))#,design_mat = design_mat,
# R = R,Emp_Cov = Emp_Cov,cov_func = cov_func))
if(class(temp_test)[1]=="try.error"){stop("First evaluation of objective function (with param_init) failed.")}
rm(temp_test)
# Perform optimisation...
Fit1 <- optim(par = gac_coef_init,
fn = internal_gac_obj,
# design_mat = design_mat,
# R = R,
# Emp_Cov = Emp_Cov,
# cov_func = cov_func,
# loss = loss,
#
method = "BFGS"
# method = "Nelder-Mead",hessian = F
)
## Return as "gac" class
param_est <- list()
gac_coef <- list()
n_gac_coef <- unlist(lapply(design_mat,ncol))
penalty <- 0
for(i in 1:length(design_mat)){
gac_coef[[i]] <- Fit1$par[sum(n_gac_coef[0:(i-1)])+1:n_gac_coef[i]]
param_est[[i]] <-  matrix(design_mat[[i]] %*% gac_coef[[i]],ncol = ncol(R))
## Smoothness penalty?
if(length(pen_mat[[i]])==0){next}
pen_dim <- cumsum(c(0,sapply(pen_mat[[i]],ncol)))
temp_coef <- gac_coef[[i]][colnames(design_mat[[i]])!="(Intercept)"]
for(j in 1:length(pen_mat[[i]])){
temp_coef2 <- temp_coef[1:ncol(pen_mat[[i]][[j]])+pen_dim[j]]
penalty <- penalty + t(temp_coef2) %*% pen_mat[[i]][[j]] %*% temp_coef2
}
}
output <- list(call=match.call(),
R=R,X=X,
Cov_Est = cov_func(r=R,params = param_est),
param_est=param_est,
gac_coef=gac_coef,
loss_final = Fit1$value,
penalty = as.numeric(penalty))
class(output) <- "gac"
return(output)
}
test_static_fit <- gac(R = R,
X = list(x1=Z),
Emp_Cov = Cov_R_sim,
cov_func = PowExp,
param_eqns = list(~1,
~1,
~1),
loss="LS")
test_static_fit
## --- Test version using sample data
test_static_fit_data <- gac(R = R,
X = list(x1=Z),
Emp_Cov = NULL,
data=data_sim,
cov_func = PowExp,
param_eqns = list(~1,
~1,
~1),
loss="LS")
test_static_fit_data
test_static_fit_data$gac_coef
test_static_fit$gac_coef
load("data/windsolar_fc.rda")
zone_dat[,g_val:=qnorm(u_val)]
zone_dat[g_val%in%c(-Inf,Inf),g_val:=NA]
gobs <- dcast(zone_dat,
kfold+issueTime~id+lead_time,
value.var = c("g_val"),
drop = TRUE)
setorder(gobs,issueTime)
gobs[,1:10]
WindSolar_Cov <- cor(gobs[,-c(1,2)],use = "pairwise.complete.obs")
col6 <- colorRampPalette(c("blue","cyan","yellow","red"))
lattice::levelplot(WindSolar_Cov,xlab="node id", ylab="node id",
col.regions=col6(600), cuts=100, at=seq(-0,1,0.01),
scales=list(x=list(rot=45),y=list(rot=45),tck=0.3,cex=0.1))
gobs <- dcast(zone_dat[id=="wind_scotland",],
kfold+issueTime~id+lead_time,
value.var = c("g_val"),
drop = TRUE)
setorder(gobs,issueTime)
gobs[,1:10]
WindScot_Cov <- cor(gobs[,-c(1,2)],use = "pairwise.complete.obs")
col6 <- colorRampPalette(c("blue","cyan","yellow","red"))
lattice::levelplot(WindScot_Cov,xlab="node id", ylab="node id",
col.regions=col6(600), cuts=100, at=seq(0,1,0.01),
scales=list(x=list(rot=45),y=list(rot=45),tck=0.3,cex=0.1))
r <- seq(0,48,by=0.5)
R <- as.matrix(dist(r))
## For correlation, need to fix sigma = 1, so covert to correlation function
PowExp_cor <- function(params,...){
PowExp(params = list(sigma=1,theta=params[[1]],gamma=params[[2]]),...)
}
## Static fit
WindScot_static_fit <- gac(R = R,
X = list(),
Emp_Cov = WindScot_Cov,
cov_func = PowExp_cor,
param_eqns = list(#~1,
~1,
~1),
loss="WLS")
lattice::levelplot(WindScot_static_fit$Cov_Est,xlab="node id", ylab="node id",
col.regions=col6(600), cuts=100, at=seq(-0.1,1,0.01),
scales=list(x=list(rot=45),y=list(rot=45),tck=0.3,cex=0.1))
# "Dist along diagonal"
N <- length(r)
Z <- matrix(rep(1:N,N) + rep(1:N,each=N) - 1, N, N)/(2*N-1)
N <- matrix(rep(r,each=length(r)),length(r),length(r))
Z1 = cos(2*pi*N/12) + cos(2*pi*t(N)/12)
WindScot_gac_fit <- gac(R = R,
X = list(x1=Z,
x2=Z1),
Emp_Cov = WindScot_Cov,
cov_func = PowExp_cor,
param_eqns = list(#~1,
~s(x1,bs="bs",k=20),
# ~s(x1,bs="bs",k=20)+x2,
# ~s(x2,k=10),
~1),
loss="WLS",smoothness_param = 0)
lattice::levelplot(WindScot_gac_fit$Cov_Est,xlab="node id", ylab="node id",
col.regions=col6(600), cuts=100, at=seq(0,1,0.01),
scales=list(x=list(rot=45),y=list(rot=45),tck=0.3,cex=0.1))
modelling_table <- data.frame(y=c(WindScot_Cov),
r=c(R),
x1=c(Z))
plot(x=modelling_table$r,
y=modelling_table$y,
col="grey",pch=".")
modelling_table$y_est <- c(WindScot_static_fit$Cov_Est)
points(x=modelling_table$r,
y=modelling_table$y_est,
col="red")
modelling_table$y_est <- c(WindScot_gac_fit$Cov_Est)
lattice::levelplot(WindScot_gac_fit$Cov_Est,xlab="node id", ylab="node id",
col.regions=col6(600), cuts=100, at=seq(0,1,0.01),
scales=list(x=list(rot=45),y=list(rot=45),tck=0.3,cex=0.1))
gobs <- dcast(zone_dat[id=="wind_scotland",],
kfold+issueTime~id+lead_time,
value.var = c("g_val"),
drop = TRUE)
setorder(gobs,issueTime)
gobs[,1:10]
WindScot_Cov <- cor(gobs[,-c(1,2)],use = "pairwise.complete.obs")
col6 <- colorRampPalette(c("blue","cyan","yellow","red"))
lattice::levelplot(WindScot_Cov,xlab="node id", ylab="node id",
col.regions=col6(600), cuts=100, at=seq(0,1,0.01),
scales=list(x=list(rot=45),y=list(rot=45),tck=0.3,cex=0.1))
WindScot_Cov <- cor(gobs[hour(issueTime)==12,][,-c(1,2)],use = "pairwise.complete.obs")
col6 <- colorRampPalette(c("blue","cyan","yellow","red"))
lattice::levelplot(WindScot_Cov,xlab="node id", ylab="node id",
col.regions=col6(600), cuts=100, at=seq(0,1,0.01),
scales=list(x=list(rot=45),y=list(rot=45),tck=0.3,cex=0.1))
lattice::levelplot(WindScot_Cov,xlab="node id", ylab="node id",
col.regions=col6(600), cuts=100, at=seq(-0.1,1,0.01),
scales=list(x=list(rot=45),y=list(rot=45),tck=0.3,cex=0.1))
WindScot_Cov <- cor(gobs[hour(issueTime)==12,][,-c(1,2)],use = "pairwise.complete.obs")
col6 <- colorRampPalette(c("blue","cyan","yellow","red"))
lattice::levelplot(WindScot_Cov,xlab="node id", ylab="node id",
col.regions=col6(600), cuts=100, at=seq(-0.1,1,0.01),
scales=list(x=list(rot=45),y=list(rot=45),tck=0.3,cex=0.1))
WindScot_Cov <- cor(gobs[hour(issueTime)==0,][,-c(1,2)],use = "pairwise.complete.obs")
col6 <- colorRampPalette(c("blue","cyan","yellow","red"))
lattice::levelplot(WindScot_Cov,xlab="node id", ylab="node id",
col.regions=col6(600), cuts=100, at=seq(-0.1,1,0.01),
scales=list(x=list(rot=45),y=list(rot=45),tck=0.3,cex=0.1))
WindScot_Cov <- cor(gobs[hour(issueTime)==0,][,-c(1,2)],use = "pairwise.complete.obs")
col6 <- colorRampPalette(c("blue","cyan","yellow","red"))
lattice::levelplot(WindScot_Cov,xlab="node id", ylab="node id",
col.regions=col6(600), cuts=100, at=seq(-0.1,1,0.01),
scales=list(x=list(rot=45),y=list(rot=45),tck=0.3,cex=0.1))
WindScot_Cov <- cor(gobs[hour(issueTime)==0,][,-c(1,2)],use = "pairwise.complete.obs")
col6 <- colorRampPalette(c("blue","cyan","yellow","red"))
lattice::levelplot(WindScot_Cov,xlab="node id", ylab="node id",
col.regions=col6(600), cuts=100, at=seq(-0.1,1,0.01),
scales=list(x=list(rot=45),y=list(rot=45),tck=0.3,cex=0.1))
