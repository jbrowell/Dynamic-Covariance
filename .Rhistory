install.packages("data.table")
require(data.table)
rm(list=ls())
require(rstudioapi)
install.packages(devtools)
install.packages("devtools")
require(devtools)
install_github("jbrowell/ProbCast")
install_github("jbrowell/ProbCast")
?install.packages
install("../GItHub/ProbCast/")
install.packages(tidyverse)
install.packages("tidyverse")
dplyr::near(sqrt(2)^2,2)
sqrt(2)^2==2
rm(list=ls())
require(rstudioapi)
require(data.table)
require(plot3D)
require(plot3Drgl)
require(mvnfast)
require(mgcv)
require(roxygen2)
require(devtools)
setwd(dirname(getActiveDocumentContext()$path))
remove.packages("gac")
# Update package documentation
document(pkg = ".")
# Install from local repository
install(".")
# Load Package
require(gac)
##  faster VS score, half the time on sR... ####
vs_sample_quick <- function (y, dat, w = NULL, p = 0.5) {
d <- length(y)
out <- 0
for (i in seq_len(d)) {
for (j in seq_len(i)){
vdat <- mean(abs(dat[i, ] - dat[j, ])^p)
vy <- abs(y[i] - y[j])^p
if (is.null(w)) {
out <- out + (vy - vdat)^2
} else {
out <- out + w[i, j] * (vy - vdat)^2
}
}
}
return(2*out)
}
## Notes for the future ####
# Try nls()... e.g. formula = cov ~ cov_function(...)
# End goal: estimate and sample mvn. This script focuses on estimating
# parametric contrivance functions.
# Alternative, estimate (sparse) precision matrix e.g. "glasso" then
# sample using "sparseMVN::rmvn.sparse()"...
## Form single-variate symmetric matrix, sample and fit  ####
r <- seq(0,3,by=0.1)
R <- as.matrix(dist(r))
Cov_R <- PowExp(R,params = c(sqrt(2),1.5,0.8))
# Cov_R <- Spherical(R)
image(t(Cov_R))
surf3D(matrix(r,length(r),length(r),byrow = F),
matrix(r,length(r),length(r),byrow = T),
Cov_R,
colvar = Cov_R, colkey = F, facets = F,bty="f",
xlab="Lead-time",ylab="Lead-time",zlab="Covariance",
zlim=c(0,1),theta = -10,phi = 10)
# plotrgl()
## Visualisations
# r <- seq(0,3,by=0.01)
# plot(r,PowExp(r),type="l",ylim = c(0,1.1))
# lines(r,Whittle_Matern(r),col=2)
# lines(r,Cauchy(r),col=3)
# lines(r,Spherical(r,theta = 2),col=4)
## Sample
data_sim <- mvnfast::rmvn(n = 2^11,mu=rep(0,ncol(Cov_R)),sigma = Cov_R)
Cov_R_sim <- cov(data_sim)
image(t(Cov_R_sim))
image(t(Cov_R_sim-Cov_R))
gac_obj(c(1,1,1),R,Cov_R_sim,cov_func=PowExp,loss="WLS")
Fit1 <- optim(par=c(1,1,1),
gac_obj,
method = "L-BFGS-B",
lower=c(0,0,0),
upper = c(Inf,Inf,2),
R=R,Emp_Cov = Cov_R_sim,
cov_func=Spherical)
Cov_R_fit <- PowExp(R,params =  Fit1$par)
plot(c(R),c(Cov_R_sim),pch=16,col=rgb(0,1,0,alpha = .1))
points(c(R),c(Cov_R),pch=16)
points(c(R),c(Cov_R_fit),pch=16,col=2)
# Remove everything apart from functions
rm(list = setdiff(ls(), lsf.str()))
## Example with changing parameter ####
require(Matrix)
r <- seq(0,1,length.out=24)
R <- as.matrix(dist(r))
Z <- r %*% t(r) # NB: Cov is no longer a function of separation only...
image(t(Z))
# True Covariance
Cov_R <- as.matrix(nearPD(PowExp(R,params = list(sigma=1,theta=2+1/(.1+sqrt(Z)),gamm=1)))$mat)
image(t(Cov_R))
# Empirical from simulation
data_sim <- mvnfast::rmvn(n = 720,
mu=rep(0,ncol(Cov_R)),sigma = Cov_R)
Cov_R_sim <- cov(data_sim)
image(t(Cov_R_sim))
modelling_table <- data.frame(y=c(Cov_R_sim),
r=c(R),
x1=c(Z))
plot(x=modelling_table$r,
y=modelling_table$y,
col=rgb(1-modelling_table$x1,0,modelling_table$x1))
test_static_fit <- gac(R = R,
X = list(x1=Z),
Emp_Cov = Cov_R_sim,
cov_func = PowExp,
param_eqns = list(~1,
~1,
~1),
loss="WLSf")
test_fit <- gac(R = R,
X = list(x1=Z),
Emp_Cov = Cov_R_sim,
cov_func = PowExp,
param_eqns = list(~1,
~s(x1,bs="bs"),
~1),
loss="WLSf",
smoothness_param = 0)
